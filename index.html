<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Trung thu vui v·∫ª nh√©</title>
    
    <!-- Meta tags cho SEO v√† chia s·∫ª m·∫°ng x√£ h·ªôi -->
    <meta name="description" content="Ch√∫c em v√† gia ƒë√¨nh lu√¥n lu√¥n h·∫°nh ph√∫c üåï‚ú®">
    <meta name="keywords" content="Trung thu, l·ªùi ch√∫c, t√¨nh y√™u, h·∫°nh ph√∫c, trƒÉng r·∫±m, messenger, facebook">
    <meta name="author" content="Trung Thu">
    
    <!-- Open Graph Meta Tags cho Facebook & Messenger -->
    <meta property="og:title" content="üåï Trung thu vui v·∫ª nh√©">
    <meta property="og:description" content="Ch√∫c em v√† gia ƒë√¨nh lu√¥n lu√¥n h·∫°nh ph√∫c üåï‚ú®">
    <meta property="og:image" content="https://trung-thu-two.vercel.app/image/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Trung thu vui v·∫ª nh√© - L·ªùi ch√∫c h·∫°nh ph√∫c v·ªõi m·∫∑t trƒÉng v√† th·ªè">
  <meta property="og:url" content="">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Trung Thu 3D">
    <meta property="og:locale" content="vi_VN">
    
    <!-- Facebook App ID cho Messenger (n·∫øu c√≥) -->
    <meta property="fb:app_id" content="">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="üåï Trung thu vui v·∫ª nh√©">
    <meta name="twitter:description" content="Ch√∫c em v√† gia ƒë√¨nh lu√¥n lu√¥n h·∫°nh ph√∫c üåï‚ú®">
    <meta name="twitter:image" content="https://trung-thu-two.vercel.app/image/og-image.png">
    <meta name="twitter:image:alt" content="Trung thu vui v·∫ª nh√© - L·ªùi ch√∫c h·∫°nh ph√∫c v·ªõi m·∫∑t trƒÉng v√† th·ªè">
    
    <!-- Additional Meta Tags cho Messenger -->
    <meta property="article:author" content="Trung Thu">
    <meta property="article:section" content="L·ªùi ch√∫c">
    <meta property="article:tag" content="trung thu, l·ªùi ch√∫c, t√¨nh y√™u">
    
    <!-- Additional Meta Tags -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ff69b4">
    <meta name="robots" content="index, follow">
    
    <link rel="stylesheet" href="css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
      /* GIF floating layer */
      #gif-layer{position:fixed;inset:0;pointer-events:none;z-index:12;}
      .floating-gif{position:absolute;bottom:-140px;opacity:0;animation:gifFly var(--dur,16s) linear infinite;filter:drop-shadow(0 6px 12px rgba(255,200,160,.35));}
      @keyframes gifFly{
        0%{transform:translateY(0) translateX(0) scale(1);opacity:.0}
        10%{opacity:1}
        90%{opacity:1}
        100%{transform:translateY(-110vh) translateX(var(--dx,20px)) scale(.95);opacity:0}
      }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <div class="loading-text">ƒêang t·∫£i d·ªØ li·ªáu...</div>
            <div class="loading-subtitle">Vui l√≤ng ch·ªù trong gi√¢y l√°t</div>
        </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen" style="display: none;">
        <div class="error-container">
            <div class="error-icon">‚ö†Ô∏è</div>
            <div class="error-title">Kh√¥ng t√¨m th·∫•y ID</div>
            <div class="error-message">Vui l√≤ng ki·ªÉm tra l·∫°i ƒë∆∞·ªùng link ho·∫∑c li√™n h·ªá ng∆∞·ªùi g·ª≠i</div>
            <button class="error-button" onclick="location.reload()">Th·ª≠ l·∫°i</button>
        </div>
    </div>

    <!-- Background stars -->
    <div class="stars" id="stars"></div>

    <!-- Audio element -->
    <audio id="backgroundMusic" loop preload="auto" crossorigin="anonymous">
        <source src="music/anhnangcuaanh.mp3" type="audio/mpeg">
        <source src="music/denbenanh.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <!-- Gift container -->
    <div class="gift-container" id="giftContainer">
        <img src="gift/rabbits.gif" alt="Gift" class="gift">
    </div>

    <!-- Gift xu·∫•t hi·ªán ·ªü g√≥c tr√°i -->
    <div class="gift-appear" id="giftAppear">
        <img src="image/gift.png" alt="Gift" class="gift-image" id="giftImage">
    </div>

    <!-- Dialog popup -->
    <div class="dialog-overlay" id="dialogOverlay">
        <div class="dialog">
            <p>Ch√∫c b√© m·ªôt m√πa Trung Thu tr√†n ƒë·∫ßy ni·ªÅm vui, h·∫°nh ph√∫c v√† may m·∫Øn! üåï‚ú®<br>
                Mong r·∫±ng nh·ªØng ƒëi·ªÅu t·ªët ƒë·∫πp nh·∫•t s·∫Ω ƒë·∫øn v·ªõi em trong nƒÉm nay!
                <br>
                ƒê√¢y l√† m√≥n qu√† c·ªßa anh d√†nh cho em
                üê∞üåô
            </p>

            <div class="dialog-image-container">
                <img src="image/dialog.png" alt="Dialog Background" class="dialog-background">
                <img src="gift/gift.gif" alt="Gift" class="qr-overlay" id="giftImage" style="cursor: pointer;" onerror="this.style.display='none'; console.error('Kh√¥ng th·ªÉ load ·∫£nh Gift:', this.src);">
            </div>

            <button onclick="closeDialog()">ƒê√≥ng</button>
        </div>
    </div>
    <!-- Moon with rabbit - Top right -->
    <div class="moon-section">
        <img src="image/moon.png" alt="TrƒÉng R·∫±m" class="moon">
        <!-- Music control button -->
        <div class="music-control" id="musicControl">
            <button id="playPauseBtn" class="play-pause-btn">
                <span id="playIcon">üéµ</span>
            </button>
  </div>

    </div>

    <!-- Flying rabbit with ribbons - Middle left -->
    <div class="flying-rabbit-section">
        <img src="image/rabbits.png" alt="Th·ªè bay" class="flying-rabbit">
    </div>

    <!-- Traditional woman - Bottom right -->
    <div class="woman-section">
        <img src="image/sister.png" alt="Ng∆∞·ªùi ph·ª• n·ªØ truy·ªÅn th·ªëng" class="woman">
    </div>

    <!-- Mountain/Cloud shapes - Bottom -->
    <div class="mountain-section">
        <img src="image/mountain.png" alt="Mountain" class="mountain">
    </div>

    <div class="floating-lanterns">
        <img src="image/lantern.png" alt="ƒê√®n l·ªìng bay" class="lantern">
        <img src="image/lantern2.png" alt="ƒê√®n l·ªìng bay" class="lantern">
        <img src="image/lantern.png" alt="ƒê√®n l·ªìng bay" class="lantern">
        <img src="image/lantern2.png" alt="ƒê√®n l·ªìng bay" class="lantern">
        <img src="image/lantern.png" alt="ƒê√®n l·ªìng bay" class="lantern">
        <img src="image/lantern2.png" alt="ƒê√®n l·ªìng bay" class="lantern">
  </div>

    <div id="ctrl" style="position:fixed;left:12px;top:12px;z-index:20;background:rgba(0,0,0,.35);padding:8px 10px;border-radius:8px;color:#fff;font:14px Arial;display:none;">
      <label>S·ªë l∆∞·ª£ng <input id="countRange" type="range" min="20" max="200" value="100"></label>
      <label style="margin-left:8px;">Thu ph√≥ng <input id="scaleRange" type="range" min="0.3" max="3" value="1" step="0.1"></label>
    </div>

    <div id="gif-layer"></div>


    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script src="./detect-devtools.js"></script>
  <script type='text/javascript'>
        // Bypass for developers
        const keyName = 'key';
        const keyValue = '9ac7ec230e0e4513578f309d6d3579ad';

        // Handle via config
        DisableDevtool({
            tkName: keyName,
            md5: keyValue,
            interval: '100',
        });
    </script>

    <script>
        // Kh√¥ng d√πng API/DB ‚Äì ch·ªâ giao di·ªán t∆∞∆°ng t√°c
        let giftLink = null;

        // Function ƒë·ªÉ l·∫•y ID t·ª´ URL parameters
        function getIdFromUrl() { return null; }

        // Function ƒë·ªÉ fetch d·ªØ li·ªáu t·ª´ API
        async function fetchDataFromAPI(id) { return null; }

        // Function ƒë·ªÉ test audio URL
        async function testAudioUrl(url) { return false; }

        // Function ƒë·ªÉ c·∫≠p nh·∫≠t audio source t·ª´ API
        async function updateAudioSource() { /* no-op: d√πng nh·∫°c m·∫∑c ƒë·ªãnh trong th·∫ª audio */ }


        // Function ƒë·ªÉ c·∫≠p nh·∫≠t URL ngay l·∫≠p t·ª©c
        function updateURLImmediately() {
            const currentUrl = window.location.href;
            const ogUrl = document.querySelector('meta[property="og:url"]');
            if (ogUrl) {
                ogUrl.setAttribute('content', currentUrl);
                console.log('ƒê√£ c·∫≠p nh·∫≠t og:url th√†nh:', currentUrl);
            }
        }

        // Function ƒë·ªÉ c·∫≠p nh·∫≠t meta tags cho chia s·∫ª m·∫°ng x√£ h·ªôi
        function updateSocialMetaTags() {
            updateURLImmediately();
            // D√πng title/description tƒ©nh ƒë√£ c√≥ trong <head>
        }

        function updateGiftLink() { /* no-op: kh√¥ng d√πng backend */ }

        // Function ƒë·ªÉ hi·ªÉn th·ªã gift v√† th·ªè
        function showGiftAndRabbit() {}
        function hideGiftAndRabbit() {}

        // Function ƒë·ªÉ hi·ªÉn th·ªã loading screen
        function showLoading() {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorScreen = document.getElementById('errorScreen');
            loadingScreen.style.display = 'flex';
            errorScreen.style.display = 'none';
        }

        // Function ƒë·ªÉ ·∫©n loading screen
        function hideLoading() {
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }

        // Function ƒë·ªÉ hi·ªÉn th·ªã error screen
        function showError() {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorScreen = document.getElementById('errorScreen');
            loadingScreen.style.display = 'none';
            errorScreen.style.display = 'flex';
        }

        // Function ƒë·ªÉ kh·ªüi t·∫°o d·ªØ li·ªáu
        async function initializeData() {
            // B·ªè qua to√†n b·ªô ki·ªÉm tra/ API ‚Üí lu√¥n hi·ªÉn th·ªã giao di·ªán t∆∞∆°ng t√°c
            hideLoading();
            return true;
        }

        // Function ƒë·ªÉ hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        function showErrorMessage(message) {
            // T·∫°o th√¥ng b√°o t·∫°m th·ªùi
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
            `;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            
            // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }

        // Create floating stars
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const numStars = 80;

            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 2 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        // Initialize stars when page loads
        window.addEventListener('load', createStars);

        // Dialog functions
        function showDialog() {
            const dialogOverlay = document.getElementById('dialogOverlay');
            dialogOverlay.classList.add('show');
        }

        function closeDialog() {
            const dialogOverlay = document.getElementById('dialogOverlay');
            dialogOverlay.classList.remove('show');
        }

        // Add click event to gift image
        document.addEventListener('DOMContentLoaded', function () {
            // C·∫≠p nh·∫≠t URL ngay khi DOM ready ƒë·ªÉ Messenger c√≥ th·ªÉ ƒë·ªçc
            updateURLImmediately();
            
            // Click v√†o gift ·ªü g√≥c tr√°i ƒë·ªÉ m·ªü dialog
            const giftAppearImage = document.getElementById('giftImage');
            if (giftAppearImage) {
                giftAppearImage.addEventListener('click', showDialog);
            }
            
            // Click v√†o gift trong dialog ƒë·ªÉ m·ªü link qu√† t·∫∑ng
            const dialogGiftImage = document.querySelector('.qr-overlay');
            if (dialogGiftImage) {
                dialogGiftImage.addEventListener('click', function() { closeDialog(); });
            }
            
            // Music control functionality
            setupMusicControls();
        });

        // Music control functions
        function setupMusicControls() {
            const audio = document.getElementById('backgroundMusic');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const playIcon = document.getElementById('playIcon');
            let isPlaying = false;

            // Set volume to 50% for better user experience
            audio.volume = 0.5;

            // Play/Pause button click handler
            playPauseBtn.addEventListener('click', function() {
                if (isPlaying) {
                    audio.pause();
                    playIcon.textContent = 'üéµ';
                    playIcon.style.opacity = '0.7';
                } else {
                    audio.play().then(() => {
                        playIcon.textContent = '‚è∏Ô∏è';
                        playIcon.style.opacity = '1';
                    }).catch(error => {
                        console.log('Audio play failed:', error);
                        // Fallback: show play button even if audio fails
                        playIcon.textContent = 'üéµ';
                    });
                }
                isPlaying = !isPlaying;
            });

            // Auto-play on mobile after user interaction
            function enableAutoPlay() {
                // Try to play audio after user interaction
                audio.play().then(() => {
                    isPlaying = true;
                    playIcon.textContent = '‚è∏Ô∏è';
                    playIcon.style.opacity = '1';
                }).catch(error => {
                    console.log('Auto-play failed:', error);
                });
            }

            // Enable auto-play after first user interaction
            let hasInteracted = false;
            document.addEventListener('click', function() {
                if (!hasInteracted) {
                    hasInteracted = true;
                    enableAutoPlay();
                }
            }, { once: true });

            // Handle audio events
            audio.addEventListener('ended', function() {
                isPlaying = false;
                playIcon.textContent = 'üéµ';
                playIcon.style.opacity = '0.7';
            });

            audio.addEventListener('error', function() {
                console.log('Audio error occurred');
                playIcon.textContent = 'üîá';
                playIcon.style.opacity = '0.5';
            });
        }


        // Gift animation - ch·ªâ ch·∫°y khi c√≥ linkQR h·ª£p l·ªá
        function startGiftAnimation() {}
        // scene + camera + renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // orbit controls (xoay quanh controls.target)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.07;

        // lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(10, 20, 10);
        scene.add(dir);

        // group ch·ª©a text (d·ªÖ set target)
        const textGroup = new THREE.Group();
        scene.add(textGroup);
        let objects = [];
        let imageObjects = [];
        let TEXT_COUNT = 100;
        let groupScale = 1;
        function applyGroupScale(){ textGroup.scale.set(groupScale, groupScale, groupScale); }

        // Function ƒë·ªÉ l·∫•y danh s√°ch c√¢u ch√∫c t·ª´ API ho·∫∑c d·ªØ li·ªáu m·∫∑c ƒë·ªãnh
        function getTexts() {
            return [
            "iu em",
            "H·∫°nh ph√∫c",
            "B√â Y√äN M√ÉI XINH ƒê·∫∏P",
            "Lu√¥n vui v·∫ª",
            "Mong t√¨nh y√™u ch√∫ng ta lu√¥n b·ªÅn l√¢u nh∆∞ trƒÉng r·∫±m ",
            "Trung thu vui v·∫ª",
            "B√â Y√äN M√ÉI XINH ƒê·∫∏P",
            "C·∫£m ∆°n em v√¨ t·∫•t c·∫£",
            "iu c√¥ng ch√∫a c·ªßa anh", 
            "i love you"
        ];
        }

        // (ƒë√£ khai b√°o ·ªü tr√™n)

        // Atlas: t√°ch c√°c ph·∫ßn t·ª´ og-image.png th√†nh sprite runtime (dataURL)
        const ATLAS_SRC = 'image/og-image.png';
        // x,y,w,h: t·ªça ƒë·ªô t∆∞∆°ng ƒë·ªëi (0..1) v·ªõi g·ªëc tr√°i-tr√™n c·ªßa ·∫£nh
        const SPRITE_REGIONS = [
          // x, y, w, h l√† khung bao r·ªông r√£i; pad gi√∫p l·∫•y tr·ªçn ch·ªß th·ªÉ
          { name:'moon',    x:0.30, y:0.08, w:0.30, h:0.30, pad:0.06 }, // trƒÉng l·ªõn
          { name:'rabbitL', x:0.02, y:0.50, w:0.32, h:0.36, pad:0.06 }, // th·ªè tr√°i + m√¢y
          { name:'rabbitR', x:0.56, y:0.40, w:0.36, h:0.48, pad:0.06 }, // th·ªè ph·∫£i + b√°nh
          { name:'lantern', x:0.68, y:0.00, w:0.14, h:0.24, pad:0.04 }  // ƒë√®n l·ªìng treo
        ];
        // Polygon mask (t·ªça ƒë·ªô tuy·ªát ƒë·ªëi 0..1 theo to√†n ·∫£nh), n·∫øu khai b√°o s·∫Ω c·∫Øt theo ƒëa gi√°c x√©o
        const SPRITE_POLYGONS = {
          moon: [ {x:0.32,y:0.10},{x:0.62,y:0.10},{x:0.62,y:0.40},{x:0.32,y:0.40} ],
          rabbitL: [ {x:0.02,y:0.52},{x:0.34,y:0.52},{x:0.34,y:0.86},{x:0.02,y:0.86} ],
          rabbitR: [ {x:0.56,y:0.42},{x:0.92,y:0.42},{x:0.92,y:0.90},{x:0.56,y:0.90} ],
          lantern: [ {x:0.70,y:0.00},{x:0.82,y:0.00},{x:0.82,y:0.24},{x:0.70,y:0.24} ]
        };
        // ∆Øu ti√™n d√πng file ƒë√£ t√°ch s·∫µn (an to√†n, kh√¥ng ƒë·ª•ng ch·ªß th·ªÉ kh√°c)
        let SPRITE_URLS = ['gift/moon.png','gift/rabbit-left.png','gift/rabbit-right.png','gift/lantern.png'];
        function buildSpritesFromAtlas(cb){
          if (SPRITE_URLS.length){ cb && cb(SPRITE_URLS); return; }
          const img = new Image();
          img.onload = ()=>{
            const W = img.naturalWidth, H = img.naturalHeight;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const urls = [];
            SPRITE_REGIONS.forEach(r=>{
              // √Åp d·ª•ng padding ƒë·ªÉ ch·∫Øc ch·∫Øn l·∫•y to√†n b·ªô ch·ªß th·ªÉ
              const pad = Math.max(0, r.pad || 0);
              let rx = Math.max(0, r.x - pad), ry = Math.max(0, r.y - pad);
              let rw = Math.min(1 - rx, r.w + pad*2), rh = Math.min(1 - ry, r.h + pad*2);
              const sx = Math.round(rx * W), sy = Math.round(ry * H);
              const sw = Math.round(rw * W), sh = Math.round(rh * H);
              // V·∫Ω v√†o canvas t·∫°m
              canvas.width = sw; canvas.height = sh;
              ctx.clearRect(0,0,sw,sh);
              // N·∫øu c√≥ polygon cho ch·ªß th·ªÉ, c·∫Øt x√©o theo ƒëa gi√°c
              const poly = SPRITE_POLYGONS[r.name];
              if (poly && poly.length>=3){
                ctx.save();
                ctx.beginPath();
                poly.forEach((p,idx)=>{
                  // Chuy·ªÉn v·ªÅ kh√¥ng gian v√πng c·∫Øt
                  const lx = (p.x - rx)/rw * sw;
                  const ly = (p.y - ry)/rh * sh;
                  if (idx===0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
                });
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
                ctx.restore();
              } else {
                // Kh√¥ng c√≥ polygon: c·∫Øt theo kh·ªëi ch·ªØ nh·∫≠t nh∆∞ tr∆∞·ªõc
                ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
              }
              // C·∫Øt b·ªè v√πng r√¨a trong su·ªët ƒë·ªÉ vi·ªÅn kh√≠t h√¨nh
              try {
                const data = ctx.getImageData(0,0,sw,sh);
                const arr = data.data; const thr = 8; // ng∆∞·ª°ng alpha
                let minX = sw, minY = sh, maxX = -1, maxY = -1;
                for (let y=0;y<sh;y++){
                  for (let x=0;x<sw;x++){
                    const a = arr[(y*sw + x)*4 + 3];
                    if (a>thr){ if (x<minX) minX=x; if (y<minY) minY=y; if (x>maxX) maxX=x; if (y>maxY) maxY=y; }
                  }
                }
                if (maxX>=minX && maxY>=minY){
                  // th√™m padding nh·ªè sau khi trim ƒë·ªÉ vi·ªÅn kh√¥ng b·ªã c·ª•t
                  const extra = 2; // px
                  const tw = Math.min(sw, maxX-minX+1 + extra*2);
                  const th = Math.min(sh, maxY-minY+1 + extra*2);
                  const sx2 = Math.max(0, minX - extra), sy2 = Math.max(0, minY - extra);
                  const c2 = document.createElement('canvas'); c2.width = tw; c2.height = th;
                  const g2 = c2.getContext('2d');
                  g2.putImageData(ctx.getImageData(sx2,sy2,tw,th),0,0);
                  urls.push(c2.toDataURL('image/png'));
                } else {
                  urls.push(canvas.toDataURL('image/png'));
                }
              } catch(e) {
                urls.push(canvas.toDataURL('image/png'));
              }
            });
            SPRITE_URLS = urls; cb && cb(urls);
          };
          img.src = ATLAS_SRC;
        }
        function getImagePaths() { return SPRITE_URLS; }

        // h√†m t·∫°o mesh ·∫£nh 3D
        function makeImageMesh(imagePath) {
            const loader = new THREE.TextureLoader();
            const texture = loader.load(imagePath, function(texture) {
                // T√≠nh t·ªâ l·ªá g·ªëc c·ªßa ·∫£nh
                const aspectRatio = texture.image.width / texture.image.height;
                
                // ƒê·∫∑t k√≠ch th∆∞·ªõc d·ª±a tr√™n t·ªâ l·ªá g·ªëc
                const baseSize = 8;
                let width, height;
                
                if (aspectRatio > 1) {
                    // ·∫¢nh ngang
                    width = baseSize;
                    height = baseSize / aspectRatio;
                } else {
                    // ·∫¢nh d·ªçc ho·∫∑c vu√¥ng
                    width = baseSize * aspectRatio;
                    height = baseSize;
                }
                
                // C·∫≠p nh·∫≠t geometry v·ªõi t·ªâ l·ªá ƒë√∫ng
                const geometry = new THREE.PlaneGeometry(width, height);
                mesh.geometry.dispose();
                mesh.geometry = geometry;
            });
            
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(8, 8); // k√≠ch th∆∞·ªõc t·∫°m th·ªùi
            const mesh = new THREE.Mesh(geometry, material);

            // th√™m thu·ªôc t√≠nh ƒë·ªÉ ƒëi·ªÅu khi·ªÉn qu·ªπ ƒë·∫°o bay
            mesh.userData = {
                originalY: mesh.position.y,
                originalX: mesh.position.x,
                originalZ: mesh.position.z,
                pattern: Math.floor(Math.random() * 3) // 0: th·∫≥ng, 1: ch√©o tr√°i, 2: ch√©o ph·∫£i
            };

            return mesh;
        }

        // ƒê·ª£i Google Fonts load xong tr∆∞·ªõc khi t·∫°o text
        document.fonts.ready.then(function() {
            console.log('Fonts loaded successfully');
        });

        // Function ƒë·ªÉ test Messenger preview
        function testMessengerPreview() {
            console.log('=== MESSENGER PREVIEW TEST ===');
            console.log('Title:', document.querySelector('meta[property="og:title"]')?.getAttribute('content'));
            console.log('Description:', document.querySelector('meta[property="og:description"]')?.getAttribute('content'));
            console.log('Image:', document.querySelector('meta[property="og:image"]')?.getAttribute('content'));
            console.log('URL:', document.querySelector('meta[property="og:url"]')?.getAttribute('content'));
            console.log('==============================');
        }

        // Kh·ªüi t·∫°o d·ªØ li·ªáu khi trang load
        window.addEventListener('load', async function() {
            // C·∫≠p nh·∫≠t URL ngay l·∫≠p t·ª©c ƒë·ªÉ Messenger c√≥ th·ªÉ ƒë·ªçc ƒë√∫ng
            updateSocialMetaTags();
            
            // Test Messenger preview
            testMessengerPreview();
            
            const success = await initializeData();
            if (success) {
                // N·∫øu sprite files ƒë√£ c√≥ th√¨ d√πng ngay, n·∫øu kh√¥ng th·ª≠ build t·ª´ atlas
                if (SPRITE_URLS.length) { createTextAndImages(); }
                else { buildSpritesFromAtlas(()=>{ createTextAndImages(); }); }
            }
        });

        function clearTexts(){
            for(const m of objects){ textGroup.remove(m); m.material?.map?.dispose(); m.material?.dispose(); m.geometry?.dispose(); }
            objects = [];
        }

        // Function ƒë·ªÉ t·∫°o text v√† ·∫£nh sau khi c√≥ d·ªØ li·ªáu
        function createTextAndImages() {
            clearTexts();
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            // h√†m t·∫°o mesh text 3D
            function makeTextMesh(message) {
                const canvas = document.createElement("canvas");
                const context = canvas.getContext("2d");

                // T·ª± ƒë·ªông t√≠nh k√≠ch th∆∞·ªõc canvas d·ª±a tr√™n ƒë·ªô d√†i ch·ªØ
                context.font = "700 64px 'Dancing Script', cursive, 'Arial', sans-serif";
                const textMetrics = context.measureText(message);
                const textWidth = textMetrics.width;
                const textHeight = 80; // chi·ªÅu cao c·ªë ƒë·ªãnh

                // ƒê·∫∑t k√≠ch th∆∞·ªõc canvas v·ªõi padding
                canvas.width = Math.max(textWidth + 40, 200); // t·ªëi thi·ªÉu 200px
                canvas.height = textHeight + 20;

                context.font = "700 64px 'Dancing Script', cursive, 'Arial', sans-serif";
                context.fillStyle = "#ff69b4";
                context.textAlign = "center";
                context.textBaseline = "middle";
                context.fillText(message, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide  // ƒë·ªÉ nh√¨n ƒë∆∞·ª£c c·∫£ m·∫∑t tr∆∞·ªõc & sau
                });

                // T·ª± ƒë·ªông t√≠nh k√≠ch th∆∞·ªõc geometry d·ª±a tr√™n canvas
                const geometryWidth = (canvas.width / 512) * 12; // t·ª∑ l·ªá v·ªõi canvas g·ªëc
                const geometryHeight = (canvas.height / 256) * 6;
                const geometry = new THREE.PlaneGeometry(geometryWidth, geometryHeight);
                const mesh = new THREE.Mesh(geometry, material);
                return mesh;
            }


            // t·∫°o nhi·ªÅu text 3D (x·∫øp so le + l·ªách cao ng·∫´u nhi√™n)
            const texts = getTexts();
            for (let i = 0; i < TEXT_COUNT; i++) {
                const text = texts[Math.floor(Math.random() * texts.length)];
                const mesh = makeTextMesh(text);
                const rowParity = (i % 2 === 0) ? -1 : 1; // so le tr√°i/ph·∫£i
                const baseY = -40 + (i * 1.2);
                const jitterY = (Math.random() - 0.5) * 3.0; // l·ªách cao ng·∫´u nhi√™n
                const x = (Math.random() - 0.5) * 80 + rowParity * 5; // so le theo h√†ng
                const y = baseY + jitterY;
                const z = (Math.random() - 0.5) * 80;
                mesh.position.set(x, y, z);
                // l∆∞u t·ªëc ƒë·ªô v√† pha ƒë·ªÉ chuy·ªÉn ƒë·ªông kh√¥ng ƒë·ªìng b·ªô
                mesh.userData.dy = 0.06 + Math.random() * 0.06; // t·ªëc ƒë·ªô bay l√™n kh√°c nhau
                mesh.userData.dx = (Math.random() - 0.5) * 0.06; // tr√¥i ngang nh·∫π
                mesh.userData.phase = Math.random() * Math.PI * 2; // pha l·ªách cao
                textGroup.add(mesh);
                objects.push(mesh);
            }

            // t·∫°o ·∫£nh n·ªïi b·ªçt (m·∫≠t ƒë·ªô th·∫•p h∆°n text)
            const imagePaths = getImagePaths();
            for (let i = 0; i < 10; i++) { // m·∫≠t ƒë·ªô th·∫•p
                let imagePath = imagePaths[Math.floor(Math.random() * imagePaths.length)];
                let imageMesh = makeImageMesh(imagePath);
                imageMesh.position.set(
                    (Math.random() - 0.5) * 80,
                    -80 + (i * 10),
                    (Math.random() - 0.5) * 80
                );
                scene.add(imageMesh);
                imageObjects.push(imageMesh);
            }


            // ƒë·∫∑t camera v√† controls target ƒë·ªÉ xoay quanh group (kho·∫£ng gi·ªØa)
            camera.position.set(0, 12, 60);
            controls.target.set(0, 10, 0);
            controls.update();
            });
        }


        function animate() {
            requestAnimationFrame(animate);

            // Animation cho text (so le & l·ªách cao li√™n t·ª•c)
            objects.forEach(obj => {
                const dy = obj.userData.dy || 0.08;
                const dx = obj.userData.dx || 0;
                const ph = obj.userData.phase || 0;
                obj.position.y += dy; // bay l√™n
                obj.position.x += dx; // tr√¥i ngang nh·∫π
                // dao ƒë·ªông nh·ªè theo pha ƒë·ªÉ tr√°nh th·∫≥ng h√†ng
                obj.position.y += Math.sin((performance.now()/1000) + ph) * 0.02;
                if (obj.position.y > 50) {
                    obj.position.y = -50; // reset xu·ªëng d∆∞·ªõi xa h∆°n ƒë·ªÉ tr√°nh ƒë·ª©t qu√£ng
                }
            });

            // Animation cho ·∫£nh v·ªõi c√°c qu·ªπ ƒë·∫°o bay kh√°c nhau
            imageObjects.forEach(imgObj => {
                const pattern = imgObj.userData.pattern;

                // Bay l√™n (t·∫•t c·∫£ ƒë·ªÅu bay l√™n)
                imgObj.position.y += 0.06;

                // Qu·ªπ ƒë·∫°o bay kh√°c nhau - ch·ªâ thay ƒë·ªïi h∆∞·ªõng bay
                if (pattern === 0) {
                    // Bay th·∫≥ng l√™n (kh√¥ng di chuy·ªÉn ngang)
                    imgObj.position.x += 0;
                } else if (pattern === 1) {
                    // Bay ch√©o sang tr√°i (di chuy·ªÉn sang tr√°i khi bay l√™n)
                    imgObj.position.x -= 0.03;
                } else if (pattern === 2) {
                    // Bay ch√©o sang ph·∫£i (di chuy·ªÉn sang ph·∫£i khi bay l√™n)
                    imgObj.position.x += 0.03;
                }

                // Reset khi bay qu√° cao - reset xa h∆°n ƒë·ªÉ li·ªÅn m·∫°ch
                if (imgObj.position.y > 70) {
                    imgObj.position.y = -90; // reset xa h∆°n ƒë·ªÉ tr√°nh kho·∫£ng tr·ªëng
                    imgObj.position.x = (Math.random() - 0.5) * 80;
                    imgObj.position.z = (Math.random() - 0.5) * 80;
                    // Random l·∫°i pattern
                    imgObj.userData.pattern = Math.floor(Math.random() * 3);
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }


        // Tinh ch·ªânh OrbitControls & t∆∞∆°ng t√°c
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.minDistance = 20;
        controls.maxDistance = 200;

        // Wheel ƒë·ªÉ thu ph√≥ng nh√≥m ch·ªØ
        window.addEventListener('wheel', (e)=>{
            groupScale *= (e.deltaY > 0 ? 0.95 : 1.05);
            groupScale = Math.max(0.3, Math.min(3, groupScale));
            applyGroupScale();
        });

        // Raycast click ƒë·ªÉ ‚Äúnh·ªãp‚Äù ch·ªØ
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('click', (e)=>{
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(objects, false);
            if (hits.length){ const m = hits[0].object; m.scale.set(1.3,1.3,1); setTimeout(()=>m.scale.set(1,1,1),300); }
        });

        // UI sliders
        const countRange = document.getElementById('countRange');
        const scaleRange = document.getElementById('scaleRange');
        countRange && countRange.addEventListener('input', ()=>{ TEXT_COUNT = parseInt(countRange.value,10) || 100; createTextAndImages(); });
        scaleRange && scaleRange.addEventListener('input', ()=>{ groupScale = parseFloat(scaleRange.value) || 1; applyGroupScale(); });

        // Floating GIFs (rabbits.gif, meo3.gif, gift.gif)
        const gifSources = ['gift/rabbits.gif','gift/meo3.gif','gift/gift.gif'];
        const gifLayer = document.getElementById('gif-layer');
        function createFloatingGif(){
          if(!gifLayer) return;
          const src = gifSources[Math.floor(Math.random()*gifSources.length)];
          const img = document.createElement('img');
          img.src = src; img.className = 'floating-gif';
          const w = 80 + Math.random()*80; // 80-160px
          const left = Math.random()*90 + 5; // 5%-95%
          const dur = 14 + Math.random()*8; // 14-22s
          const delay = Math.random()*4; const dx = (Math.random()-0.5)*80 + 'px';
          img.style.width = w+'px';
          img.style.left = left+'%';
          img.style.setProperty('--dur', dur+'s');
          img.style.setProperty('--dx', dx);
          img.style.animationDelay = delay+'s';
          gifLayer.appendChild(img);
          setTimeout(()=> img.remove(), (dur+delay)*1000 + 500);
        }
        // seed & low density loop
        for(let i=0;i<3;i++) setTimeout(createFloatingGif, i*1500);
        setInterval(createFloatingGif, 4000);

        animate();

        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>